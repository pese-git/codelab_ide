# План внедрения LSP (Dart Analysis Server) в Codelab IDE

---

## Итерация 1. Подключение lsp_client и старт сервера

**Цель:** Minimal integration — запускать Dart Analysis Server отдельно от редактора, коммуницировать простыми LSP-запросами (например, version), логировать ответы.

**Шаги:**
1. Добавить зависимость lsp_client в package (лучше codelab_engine).
2. Имплементировать DartLspManager — сервис, который умеет стартовать dart analysis server и отправить ему message initialize.
3. Проверить, что можно получить capabilities от сервера (например, отправить initialize и получить response).
4. UI: добавить командную кнопку “Запустить LSP” — её нажатие логирует обмен с сервером.

**Результат:**
- Проект компилируется и запускается. Можно стартовать LSP-сервер и увидеть его “ping” в логах.

---

## Итерация 2. Поддержка didOpen и diagnostics из LSP

**Цель:** Редактор при открытии файла отправляет didOpen, ошибки сервера отображаются в лог/простом overlay.

**Шаги:**
1. Модифицировать EditorCodeField, чтобы на открытие файла через DartLspManager отправлялся textDocument/didOpen с содержимым файла.
2. DartLspManager слушает diagnostics из LSP и логирует/сохраняет их.
3. UI: в редакторе добавить acknowledgment-индикатор “Анализируем…”, и выводить список ошибок/diagnostics (пока простым списком в UI).
4. Пользователь открывает Dart-файл — получает подсвеченные ошибки от анализа.

**Результат:**
- При открытии файлов в редакторе появляется минимальная поддержка диагностики Dart — видны ошибки из analysis server.

---

## Итерация 3. Поддержка live-diagnostics (didChange, live update)

**Цель:** При изменениях текста автоматически уходят didChange, diagnostics обновляются “на лету”.

**Шаги:**
1. В EditorCodeField подключить onTextChanged → вызывается textDocument/didChange через LspManager.
2. LspManager слушает обновления diagnostics, UI перерисовывает ошибки поверх текста.
3. Реализовать базовую визуальную подсветку ошибок/диагностик прямо в редакторе.

**Результат:**
- В редакторе видно как ошибки меняются при редактировании Dart-кода почти в реальном времени.

---

## Итерация 4. Hover & автокомплит (go to definition, подсказки)

**Цель:** Реализовать базовые LSP-фичи по наведению курсора и автокомплита.

**Шаги:**
1. На hover по коду вызывать LSP-запрос textDocument/hover и показывать тултип с информацией.
2. По запросу автокомплита или на хоткей вызывать completion → показывать список вариантов автодополнения.
3. (Опционально для минимального go to definition: обрабатываем textDocument/definition, перемещаем каретку.)

**Результат:**
- В редакторе доступны инспекция типов/документации по наведению и автодополнение из analysis server.

---

## Итерация 5. Code actions и рефакторинг

**Цель:** Поддержать быстрые фиксы и рефакторинг через LSP.

**Шаги:**
1. На выделении кода или ошибке отправлять textDocument/codeAction и показывать popup со списком фиксов.
2. Поддерживать executeCommand/WorkspaceEdit — вносить изменения по команде сервера.
3. Включить поддержку rename (массовое переименование).

**Результат:**
- Пользователь может применять автоматические фиксы и рефакторинги, предложенные Dart LSP.

---

## Итерация 6. Интеграция с AI Agent (если нужно)

**Цель:** Связать LSP-функции с вашим AI Agent — чтобы предложения агента оформлялись как LSP-правки.

**Шаги:**
1. AI Agent при генерации совета/фикса может либо напрямую инициировать LSP-операцию (например, rename), либо вносить WorkspaceEdit через LSPManager.
2. (Опционально) Показывать пользователю варианты от AI и LSP в едином popup для выбора.

**Результат:**
- AI‑советы (quick fix, rename, extract) автоматом трансформируются в понятные, undoable изменения в редакторе.

---

# Итог:
- После каждой итерации есть независимая рабочая сборка с небольшой новой LSP-фичей.
- Можно тестировать, дебажить и выкатывать по кускам (и даже оставить на ранней стадии рабочего только чтения diagnostics).
- При ошибках всегда откат на предыдущую рабочую итерацию.
